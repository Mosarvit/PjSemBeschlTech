#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Sat Feb 18 15:49:32 2017

@author: Armin Galetzka, Denys Bast
Returns the FFT amplitude and the frequency vector for a given signal

Input:  singal   --------  signal in time domain
        Fns      --------  sample frequency
        
Output  frq      --------  frequency vector
        ampl     --------  vector with amplitude
        phase    --------  vector with the phase
        H        --------  vector with complex frequency domain
"""
import numpy as np

def get(signal, Fns):
    
    # -------- get FFT 
    n = signal.size
    H = np.fft.fft(signal)
    amplH = abs(H)
    
    # get frequency vector and normalize frequency domain
    fn = Fns/2
    df = Fns/n
    frq = np.arange(0,fn,df)
    ind = int(np.round(n/2))
    ampl = np.append(amplH[0]/n, amplH[1:ind]/(n/2))
    H = np.append(H[0]/n, H[1:ind]/(n/2))
    phase = np.angle(H)
    return (frq, ampl, phase, H)


def spectrum_From_FFT(frequencies, fft_norm):
    """
    calculates the frequency axis and the spectrum usable for a real signal by applying Nyquists Theorem
    :param frequencies: the frequency axis, evenly spaced, increasing orderd
    :param fft_norm: the fft of a time signal generated by numpy.fft(...)
    :return: the spectrum and frequencies reduced to the describable frequency-range (Nyquist)
    """

    # check length
    if len(frequencies) != len(fft_norm):
        raise TypeError('Frequency and FFT have to contain same number of values')

    # find max Frequencies (Nyquists theorem):
    idx_half = int(np.floor(len(fft_norm) / 2))
    # cut frequencies and FFTs to new Range -> only relevant frequencies ocurring
    frequencies = frequencies[0:idx_half]
    spectrum = fft_norm[0:idx_half] / len(fft_norm)

    return (frequencies, spectrum)


def spectrum_from_TimeSignal(time, values):
    """

    :param time: evenly spaced time array 1xn
    :param values: real values raised at points in time, size 1xn
    :return: frequency axis and complex spectrum of phaseshift and amplifier(c = abs(c) * exp(1j * np.angle(c)) )
    """
    # check length
    if len(time) != len(values):
        raise TypeError('Time-Array and Values have to contain same number of values')

    # check if values not complex
    # check if time evenly spaced
    N = len(time)
    delta_t = (time[1] - time[0])
    f_sample = 1 / delta_t
    delta_f = f_sample / N
    frequencies = np.linspace(0, N * delta_f, N)
    frequencies, spectrum = spectrum_From_FFT(frequencies, np.fft.fft(values))

    return (frequencies, spectrum)