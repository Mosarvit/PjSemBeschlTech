#!/usr/bin/python3
#@author: Mohamed Ghanmi
from __future__ import division
import sys ,os, colorama, argparse
import pandas as pd
from pandas import read_csv
import numpy as np

version_string = 'Rev. 0.0.0, 20.06.2018'

def save(Ueberschreiben,input_file,output_file):
	if "." in output_file:
		flag = output_file.split('.')[0]
	else:
		flag = output_file

	fname = flag + '.csv'

	#read old data
	old_data =[]

	if os.path.isfile(fname):
		old_file = read_csv(fname)
		for i in range(1,27):
			temp = old_file.values[:,i][3:]
			if len(temp) == 1:
				old_data.append(np.array([float(temp)]))
			else:
				old_data.append(np.array(temp).astype(np.float))
		old_names =  old_file.values[:,0][3:]
		old_data.insert(0,old_names)

	#read input file
	input_file = read_csv(input_file)
	new_data = [float(input_file.values[:,x][3]) for x in range(1,27)]#
	name = input_file.values[:,0][3]

	new_data.insert(0,name)


	keys = input_file.values[2,:]
	d = dict(zip(keys, new_data))

	d_old = {}

	if Ueberschreiben == 1:
		res = d
		if os.path.isfile(fname):
			os.system("rm {}".format(fname))
	else:
		if len(old_data) == 0:
			res = d
		else:
			input_file = read_csv(fname)
			keys = input_file.values[2,:]
			d_old = dict(zip(keys, old_data))

			for key in d_old:
				d_old[key] = np.append(d_old[key],d[key])

			res = d_old

	rows = len([res['Amplitude']])
	df = pd.DataFrame(dict([ (k,pd.Series(v)) for k,v in res.items() ]))

	# get count of header columns, add REAL for each one
	types_header_for_insert = list(df.columns.values)
	for idx, val in enumerate(types_header_for_insert):
		types_header_for_insert[idx] = ' '

	# count number of index columns, then add STRING for each one
	index_count = len(df.index.names)
	for idx in range(0, index_count):
		df.reset_index(level=0, inplace=True)
		types_header_for_insert.insert(0, ' ')

	column_information = [[0,0,1,x] for x in res.keys()]

	temp = [x[3] for x in column_information]
	df = df[temp]
	df.loc[-1]  = temp
	temp = [x[0] for x in column_information]
	#temp.insert(0, ' ')
	df.loc[-2]  = temp
	temp = [x[1] for x in column_information]
	df.loc[-3]  = temp
	temp = [' ' for x in temp]

	#sort index
	print('%s is written'%(flag+'.csv'))
	temp = [x[3] for x in column_information]
	temp.remove('Name')
	temp.sort()
	temp.insert(0, 'Name')
	df = df[temp]
	temp[0:4] = ['Column file','columns={}'.format(len(column_information)),'rows={}'.format(rows),'generated by singlesine_save_results']
	for x in range(4,len(temp)):
		temp[x] = ' '
	df.loc[-4]  = temp
	df = df.sort_index()
	df.to_csv(flag+'.csv',index=False,header=False)



if __name__ == "__main__":
	# Initialization of colored text output:
	colorama.init()
	copyright_message = "copyright_message: Still to be determined"
	# Parse the command line arguments:
	parser = argparse.ArgumentParser(description=copyright_message+'This tool is a python version of Eingabedatei.m.' + ' ' + version_string + '.')

	#Reading the parameters
	parser.add_argument('-i', action="store", dest="input_file", required=True, help='Name of input file.')
	parser.add_argument('-u', action="store", dest="overwrite", required=True, help='specifies whether existing files should be overwritten.')
	parser.add_argument('-o', action="store", dest="output_file", required=True, help='Name of output file.')

	parse_result = parser.parse_args(sys.argv[1:])


	print(colorama.Back.GREEN + colorama.Style.BRIGHT + "singlesine_save_results: Start." + colorama.Style.NORMAL + colorama.Back.RESET)

	input_file = parse_result.input_file
	overwrite = int(parse_result.overwrite)
	out_file = parse_result.output_file
	save(overwrite,input_file,out_file)
	print(colorama.Back.GREEN + colorama.Style.BRIGHT + "singlesine_save_results: Done." + colorama.Style.NORMAL + colorama.Back.RESET)
	print('\n')
	# Return code 0 (success):
	sys.exit(0)
