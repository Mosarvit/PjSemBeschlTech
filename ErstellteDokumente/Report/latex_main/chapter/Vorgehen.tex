\documentclass[../Report.tex]{subfiles}


\begin{document}


\chapter{Vorgehen}
\label{chap:vorgehen}
In diesem Kapitel werden die wichtigsten Punkte in der Weiterentwicklung des vorhandenen Tools erklärt. Dabei wird unsere Methodik vorgestellt an den vorhandenen Weg anzuschließen und weiter fortzusetzen im Hinblick darauf, dass an das Projekt von anderen Personen angesetzt werden kann.
\section[Vorhandene Implementierung]{Vorhandene Implementierung}
\label{sec:vorg.setup}
Unser Projekt setzt an 2 Punkten an. Zum einen das Projektseminar \cite{PJS_Denys}, in dem der Grundstein in Python gelegt wurde und zum anderen eine funktionierende Implementierung de nichtlinearen Bestandteils des Modells aus \figref{fig:Hammerstein} nach der Vorstellung aus \cite{harzheim}.
\subsection{Python}
\label{sec:vorg.python}
Das vorhandene Python Tool konnte mit einem Pseudorauschen die Übertragungsfunktion des Systems im linearen Bereich bestimmt werden. Diese Funktionalität haben wir vollständig übernommen. Darüber hinaus waren folgende Funktionalitäten implementiert:
\begin{itemize}
	\item	$\Hcompl$ auf das Spektrum von $\Uout_{,ideal}$ anzuwenden.
	
	\item	Signale an das AWG zu senden und vom Oszilloskop zu messen.
	
	\item	aus gegebenen Koeffizienten $a_n$ eine Kennlinie als Look-Up Tabelle zu berechnen.
\end{itemize}
\subsection{MATLAB}
\label{sec:vorg.matlab}
Als zweiten Ansatzpunkt hatten wir funktionierende Methoden aus der MATLAB Implementierung des nichtlinearen Teils mit folgenden Funktionalitäten:
\begin{itemize}
	\item	$\Hcompl$ auf das Spektrum von $\Uout_{,ideal}$ anzuwenden.
	
	\item	$a_n$ für die nichtlineare Kennlinie zu berechnen.
	
	\item	$K$ als Look-Up Tabelle aufzustellen.
	
	\item	ein vorverzerrtes Eingangssignal über $K$ zu berechnen.
\end{itemize}

\section[Funktionalität reproduzieren]{Funktionalität reproduzieren}
\label{sec:vorg.reproduktion}
Als ersten wurde versucht die vorhandene Implementierung zu überblicken und letztendlich beide in Python zusammenzuführen. Dabei wurde eine starke Kopplung festgestellt, was die Fehlersuche und Fortführung erschwerte. Ein paar Funktionen hatten teilweise auch mehrere logische Aufgaben, die für eine bessere Verständlichkeit getrennt werden sollten. Mit dem Code wurden schon gute Ergebnisse erzielt und das erste Ziel war, den Code in eine neue Form zu überführen, ohne die Funktionalität zu beeinträchtigen.
\subsection{Neues Design}
\label{sec:vorg.design}
Das in \figref{fig:Hammerstein} dargestellte Modell wird in zwei Blöcke gegliedert und so wurde ein Code-Design gewählt, das diese Blöcke repräsentiert. Dafür bietet sich ein modulares Design an, das in Kap. \ref{chap:code} genauer erklärt ist und dabei möglichst selbsterklärend dieses Modell abbildet.
\subsection{Tests}
\label{sec:vorg.tests}

\subsection{Fehlersuche}
\label{sec:vorg.fehlersuche}

\section[Funktionalität erweitern]{Funktionalität erweitern}
\label{sec:vorg.erweiterung}

\subsection{Erste Optimierungs Idee}
\label{sec:vorg.optimierung}

\subsection{Laufzeit Optimierung}
\label{sec:vorg.laufzeit}

\section{Gerätekommunikation}
\label{sec:vorg.geraete}

Um Messergebnisse sinnvoll für die Verarbeitung in Python aufzunehmen, ist eine effiziente Kommunikation zwischen den Messgeräten und dem angeschlossenen Computer essentiell. Besonders relevant ist hier die zeitliche Abstimmung zwischen Computer und Gerät sowie die bestmögliche Nutzung der Genauigkeiten der verwendeten Geräte. 
Hierbei wurden die zu Beginn vorliegenden Implementierungen für die Gerätekommunikation erweitert, wobei vor allem
\begin{enumerate}
	\item die Optimierung der Laufzeit beim Schreiben und Lesen von Gerätewerten sowie
	\item die Anpassung der Darstellung des Oszilloskops an die gemessenen Daten für eine höhere Genauigkeit
\end{enumerate}
Ziele der Anpassungen waren.
\\
\\
Die Fernsteuerung von Messgeräten, der \lstinline{Remote}-Modus, wird standardmäßig durch das Visa-Protokoll und im vorliegenden Fall durch die Implementierung von National Instruments, NIVisa, geregelt. Die Einbindung in Python wird durch die Erweiterung PyVisa ermöglicht. Übertragen werden Befehle in Form standardisierter Befehlsstrukturen, den SCPI (Standard Commands for Programmable Instruments). Dem inneren Aufbau von Messgeräten zugrunde liegt der IEE-488 Standard, sodass unabhängig vom konkreten Gerät oder der Art der Verbindung eine Reihe von Befehlen existiert, die gemäß IEE-488.2 gebräuchliche Standards bieten \cite[S. 224 ff.]{keysHand15}.
Weiterhin bieten die Geräte spezifische Befehle zur Manipulation der Einstellungen, die in großer Analogie zur direkten Benutzeroberfläche formuliert sind. Diese werden nach Kontext gegliedert in sogenannte Subsysteme oder Command Groups.


\subsubsection{Laufzeitoptimierung}
Im vorliegenden Messaufbau ist es notwendig, beim Konfigurieren des AWG alle Einstellungen zurückzusetzen und anschließend neu zu setzen. Dabei werden Befehle nach dem First-Come-First-Serve Prinzip aus dem internen Speicher abgearbeitet. Dies führt aufgrund begrenzter Speicherkapazität und Verarbeitungsgeschwindigkeit bei einer Reihe von Befehlen zur Notwendigkeit, das Senden von Befehlen im Programm mit dem Arbeitsstatus des Gerätes zu synchronisieren. Einen Eindruck der zeitlichen Größenordnung bietet \tabref{tab:vorg.gerate.runtime}.

\begin{table} 
\begin{subtable}[t]{.35\linewidth}
\subcaption{Knotenliste}
\label{ta}
\begin{tabular}[t]{ | c | c | c | c | } 
  \hline
    $P_{\#}$ & $x$ & $y$ \\ 
  \hline
    $1$ & $\cos(72\degree)$ 	& $\sin(72\degree)$ \\ 
  \hline
    $2$ & $1$ 				& $0$ \\
  \hline
    $3$ & $\cos(72\degree)$ 	& $-\sin(72\degree)$ \\
  \hline
    $4$ & $-\cos(36\degree)$ & $-\sin(36\degree)$ \\
  \hline
    $5$ & $-\cos(36\degree)$ & $\sin(36\degree)$ \\
  \hline
    $6$ & $0$ 				& $0$ \\  
  \hline  
\end{tabular}
\end{subtable}
\caption{Laufzeit unterschiedlicher Befehle am Keysight 33622A}
\label{tab:vorg.gerate.runtime}
\end{table}

In der zu Beginn vorliegenden Implementierung lagen pauschale Wartezeiten nach einigen Befehlen sowohl in der Ansteuerung des AWG als auch des Oszilloskops vor. 

Die Wartezeiten für das AWG wurde letztendlich mit
--------------------------------------------------
--------------------------------------------------
angepasst. Die Laufzeit der Routine zum Schreiben eines Arbiträrsignals in der speziellen hier geforderten Form wurde damit von etwa $\SI{25}{\s}$ auf ungefähr --- reduziert.
\\
Erfolglos blieben Versuche mit einigen anderen Standardbefehlen.
\lstinline{*WAI} und \lstinline{*BUSY?} sind keine für das AWG definierten Befehle.
\lstinline{*OPC?} zwingt Python zum Warten auf Beenden aller Befehle im AWG und führt zu einem \lstinline{TimeoutError}, da die Ausführung zu lange für die internen Routinen von Python braucht, vergleiche hierfür \cite[S. 9]{troeser13}.
Weiterhin wurde die pauschale Wartezeit an der im Datenblatt \cite[S. 21]{keysData14} für die Verbindung via USB angegebenen, gemessenen Ladedauer eines Arbiträrsignals orientiert. Dieser Richtwert von $\SI{1.25}{\s}$ stellte sich jedoch als zu gering für den hier vorliegenden Fall heraus.
\\
\\
Es wurde festgestellt, das die Verarbeitungsgeschwindigkeit des Oszilloskops bei den hier benötigten Abfragen und Befehlen kein Hindernis darstellt und die Ausführung der Befehle in Python ohne Zeitverzögerung möglich ist. Durch diese Feststellung konnte die Laufzeit je Lese-Aufruf bereits um ungefähr $\SI{15}{\s}$ reduziert werden.
Bei den zur Sicherheit implementierten Warte-Befehlen handelt es sich um Status-Abfragen ähnlich den oben für das AWG erläuterten.
\\
\\
Letztlich sei erwähnt, dass die Abfrage der Fehler im AWG mittels  \lstinline{SYSTem:ERRor?} möglich ist und durch das dabei erfolgte Löschen der Fehler aus dem internen Speicher nicht nur die Abfrage sondern auch das Rücksetzen des Fehlerstatus ermöglicht. Dies ist insbesondere für das Debugging vorteilhaft, wenn Befehle ausprobiert werden und die gegebenenfalls auftretenden Fehler gehandhabt werden müssen \cite[S. 454]{keysHand15}. Dies vermeidet das unter Umständen mehrmalige Trennen und Wiederherstellen der Verbindung zum AWG sowie das Löschen der Fehler an der Benutzeroberfläche.

\subsubsection{Anpassung der horizontalen Auflösung am Oszilloskop}

Um die Auflösung des Oszilloskops ausnutzen zu können, ist die Anpassung der horizontalen wie auch vertikalen Auflösung an das zu messende Signal notwendig.
Während die horizontale Auflösung durch die Wiederholfrequenz des Pulses mit $f_{BB}$ sich nahezu unabhängig des betrachteten Signals setzen lässt, muss die vertikale Skalierung an das Signal angepasst werden. Um dies etwa während einer Optimierung mit wechselnden Spannungsamplituden zu ermöglichen, sind zwei direkt aufeinander folgende Messungen notwendig. Dabei wird aus der ersten Messung die Amplitude des Signals entnommen und die Skalierung für die zweite, dann genauere Messung, dahingehend angepasst, dass das Signal bildfüllender dargestellt wird.
Dieser Gewinn an Genauigkeit in der Messung stellte sich insbesondere für die \nameref{sec:opt.H} als notwendig heraus.


\section{Kritische Punkte}
\label{sec:vorg.critical}

Infolge der Auseinandersetzung mit dem anfangs vorliegenden Code sowie im Zuge der Ausarbeitung sind einige Punkte aufgetreten, an deren Bedeutung die implementierte Funktionalität teilweise essentiell hing, die jedoch im Zuge der Implementierung für Probleme sorgten. Diese seien aufgrund ihrer unterschiedlichen Natur hier stichpunktartig erläutert:
\begin{itemize}
	\item	Bei diskreten Zeitsignalen ist zu beachten, dass die Periodendauer $T$ nicht durch die Differenz der Zeitwerte des letzten und des ersten Wertes, sondern noch zuzüglich eines Zeitschritts  zu berechnen ist, also \lstinline{T = time[end] - time[0] + delta_time}, womit gelten sollte \lstinline{T = N * delta_time}. Dies wirkt sich insbesondere auch auf die FFT aus, wenn die zugehörige Frequenzachse berechnet werden muss.
\end{itemize}


\end{document}